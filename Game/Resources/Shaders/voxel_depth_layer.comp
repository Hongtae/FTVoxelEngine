#version 450
#extension GL_EXT_shader_explicit_arithmetic_types         : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : require
#extension GL_EXT_debug_printf : enable

layout (push_constant) uniform SceneInfo {
    layout(row_major) mat4 inverseM;   // inverse of model transform
    layout(row_major) mat4 inverseMVP; // inverse of model-view-projection
    layout(row_major) mat4 mvp;
    vec4 ambientColor;
    vec4 lightColor;
    vec3 lightDir;
    uint32_t width;  // framebuffer(render-target) dimensions
    uint32_t height;
} info;

struct EncodedAABB {
    uint16_t x, y, z;
    uint8_t depth;
    uint8_t flags;
    uint32_t advance;
    uint32_t color;
};

layout (binding=0, rgba8) uniform image2D outputImage;
layout (binding=1, r32f) uniform image2D depthBuffer;

layout (std140, binding=2) readonly buffer AABBArray {
    EncodedAABB volumes[];
} data;

struct AABB {
    vec3 min;
    vec3 max;
};

struct Ray {
    vec3 origin;
    vec3 dir;
};

Ray getRay() {
    float x = (float(gl_GlobalInvocationID.x) + 0.5) / float(info.width);
    float y = (float(gl_GlobalInvocationID.y) + 0.5) / float(info.height);
    x = x * 2.0 - 1.0;
    y = 1.0 - y * 2.0;

    vec4 start4 = vec4(x, y, 0.0, 1.0) * info.inverseMVP;
    vec4 end4 = vec4(x, y, 1.0, 1.0) * info.inverseMVP;
    vec3 start = start4.xyz / start4.w;
    vec3 end = end4.xyz / end4.w;

    return Ray(start, normalize(end - start));
}

float rayTest(const AABB aabb, const Ray ray) {
    bool inside = true;
    vec3 maxT = vec3(-1, -1, -1);
    vec3 coord = vec3(0, 0, 0);

    for (int i = 0; i < 3; ++i) {
        if (ray.origin[i] < aabb.min[i]) {
            coord[i] = aabb.min[i];
            inside = false;
            if (ray.dir[i] != 0.0) {
                maxT[i] = (aabb.min[i] - ray.origin[i]) / ray.dir[i];
            }
        } else if (ray.origin[i] > aabb.max[i]) {
            coord[i] = aabb.max[i];
            inside = false;
            if (ray.dir[i] != 0.0) {
                maxT[i] = (aabb.max[i] - ray.origin[i]) / ray.dir[i];
            }
        }
    }
    if (inside) return 0.0;

    int plane = 0;
    if (maxT.y > maxT[plane]) plane = 1; // y-axis
    if (maxT.z > maxT[plane]) plane = 2; // z-axis

    if (maxT[plane] < 0.0)
        return -1.0;

    for (int i = 0; i < 3; ++i) {
        if (i != plane) {
            coord[i] = ray.origin[i] + maxT[plane] * ray.dir[i];

            if (coord[i] < aabb.min[i] || coord[i] > aabb.max[i])
                return -1.0;
        }
    }
    return length(coord - ray.origin);
}

AABB normalizedAABB(EncodedAABB e) {
    float x = float(e.x) / 65535.0;
    float y = float(e.y) / 65535.0;
    float z = float(e.z) / 65535.0;
    float ext = 0.5 * pow(0.5, e.depth);
    return AABB(vec3(x-ext, y-ext, z-ext), vec3(x+ext, y+ext, z+ext));
}

struct Sphere {
    vec3 center;
    float radius;
};

float rayTest(const Sphere sphere, const Ray ray) {
    vec3 oc = ray.origin - sphere.center;
    float b = 2.0 * dot(oc, ray.dir);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = b*b - 4*c;
    if (discriminant < 0.0) return -1.0;
    return (-b - sqrt(discriminant)) * 0.5;
}

Sphere normalizedSphere(EncodedAABB e) {
    float x = float(e.x) / 65535.0;
    float y = float(e.y) / 65535.0;
    float z = float(e.z) / 65535.0;
    float radius = 0.5 * pow(0.5, e.depth);
    return Sphere(vec3(x, y, z), radius);
}

float rayResultNearDepth = 1.0;
vec4 rayResultNearColor = vec4(0);
vec3 rayResultNormal = vec3(0);

void runTest(const Ray ray) {
    uint32_t index = 0;
    uint32_t count = data.volumes.length();
    while (index < count) {
        const EncodedAABB e = data.volumes[index];
        const AABB aabb = normalizedAABB(e);
        const float t = rayTest(aabb, ray);
        if (t >= 0.0 && t < rayResultNearDepth) {
            if (e.flags != 0) { // leaf-node (has material)
                const uint32_t p = e.color;
                rayResultNearColor.r = float(p & 0xff) / 255.0;
                rayResultNearColor.g = float((p >> 8) & 0xff) / 255.0;
                rayResultNearColor.b = float((p >> 16) & 0xff) / 255.0;
                rayResultNearColor.a = float((p >> 24) & 0xff) / 255.0;
                rayResultNearDepth = t;

                vec3 hitPoint = ray.origin + ray.dir * t;
                vec3 center = (aabb.max + aabb.min) * 0.5;
                vec3 n = hitPoint - center;
                rayResultNormal = normalize(n);
            }
            index += 1;
        } else {
            if (e.flags == 0)
                index += e.advance;
            else
                index += 1;
        }
    }
}

vec3 boxNormal(vec3 n) {
    vec3 absn = abs(n);
    if (absn.x > absn.y && absn.x > absn.z) {
        n.yz = vec2(0.0);
    } else if (absn.y > absn.x && absn.y > absn.z) {
        n.xz = vec2(0.0);
    } else {
        n.xy = vec2(0.0);
    }
    return normalize(n);
}

vec3 ndcToAABB(float d) {
    float x = (float(gl_GlobalInvocationID.x) + 0.5) / float(info.width);
    float y = (float(gl_GlobalInvocationID.y) + 0.5) / float(info.height);
    x = x * 2.0 - 1.0;
    y = 1.0 - y * 2.0;
    vec4 pt = vec4(x, y, d, 1.0) * info.inverseMVP;
    vec3 p = pt.xyz / pt.w;
    return p;
}

float aabbPtToNDC(const Ray ray, float depth) {
    vec3 pt = ray.origin + ray.dir * depth;
    vec4 v = vec4(pt.xyz, 1.0) * info.mvp;
    return v.z / v.w;
}

void main() {
    const Ray ray = getRay();
    float depth = imageLoad(depthBuffer, ivec2(gl_GlobalInvocationID.xy)).r;

    vec3 aabbDepthClip = ndcToAABB(depth);
    float depth2 = length(aabbDepthClip - ray.origin);
    rayResultNearDepth = depth2;
    runTest(ray);
    if (rayResultNearDepth < depth2) {
        vec3 normal = boxNormal(rayResultNormal);
        normal = normalize((vec4(normal, 0.0) * info.inverseM).xyz);
        float lum = max(dot(normal, normalize(-info.lightDir)), 0.0);
        vec3 color = mix(info.ambientColor.rgb, info.lightColor.rgb * lum, info.lightColor.a);
        vec4 fragColor = rayResultNearColor * vec4(color, 1.0);
        imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), fragColor);

        float depth3 = aabbPtToNDC(ray, rayResultNearDepth);
        imageStore(depthBuffer, ivec2(gl_GlobalInvocationID.xy), vec4(depth3));
    }
}
