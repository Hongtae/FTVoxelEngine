#version 450
#extension GL_EXT_shader_explicit_arithmetic_types         : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : require
#extension GL_EXT_debug_printf : enable

layout (push_constant) uniform SceneInfo {
    layout(row_major) mat4 inverseM; // inverse of model projection
    layout(row_major) mat4 inverseMVP; // inverse of model-view-
    vec4 ambientColor;
    vec4 lightColor;
    vec3 lightDir;
    uint32_t width;  // framebuffer(render-target) dimensions
    uint32_t height;
    float depth;     // frustum depth (farZ - nearZ)
} info;

struct EncodedAABB {
    uint16_t x, y, z;
    uint8_t depth;
    uint8_t flags;
    uint32_t payload;
    uint32_t padding;
};

layout (std140, binding=0) readonly buffer AABBArray {
    vec3 aabbMin;
    float _padding_12;
    vec3 aabbMax;
    float _padding_28;
    EncodedAABB volumes[];
} data;

layout (binding=1, rgba8) uniform image2D outputImage;

struct Ray {
    vec3 origin;
    vec3 dir;
};

Ray getRay() {
    float x = (float(gl_GlobalInvocationID.x) + 0.5) / float(info.width);
    float y = (float(gl_GlobalInvocationID.y) + 0.5) / float(info.height);
    x = x * 2.0 - 1.0;
    y = 1.0 - y * 2.0;

    vec3 scale = data.aabbMax - data.aabbMin;

    vec4 start4 = vec4(x, y, 0.0, 1.0) * info.inverseMVP;
    vec4 end4 = vec4(x, y, 1.0, 1.0) * info.inverseMVP;
    vec3 start = start4.xyz / start4.w;
    vec3 end = end4.xyz / end4.w;

    start = (start - data.aabbMin) / scale;
    end = (end - data.aabbMin) / scale;

    return Ray(start, normalize(end - start));
}

struct AABB {
    vec3 min;
    vec3 max;
};

float rayTest2(const AABB aabb, const Ray ray) {
    bool inside = true;
    vec3 maxT = vec3(-1, -1, -1);
    vec3 coord = vec3(0, 0, 0);

    for (int i = 0; i < 3; ++i) {
        if (ray.origin[i] < aabb.min[i]) {
            coord[i] = aabb.min[i];
            inside = false;
            if (ray.dir[i] != 0.0) {
                maxT[i] = (aabb.min[i] - ray.origin[i]) / ray.dir[i];
            }
        } else if (ray.origin[i] > aabb.max[i]) {
            coord[i] = aabb.max[i];
            inside = false;
            if (ray.dir[i] != 0.0) {
                maxT[i] = (aabb.max[i] - ray.origin[i]) / ray.dir[i];
            }
        }
    }
    if (inside) return 0.0;

    int plane = 0;
    if (maxT.y > maxT[plane]) plane = 1; // y-axis
    if (maxT.z > maxT[plane]) plane = 2; // z-axis

    if (maxT[plane] < 0.0)
        return -1.0;

    for (int i = 0; i < 3; ++i) {
        if (i != plane) {
            coord[i] = ray.origin[i] + maxT[plane] * ray.dir[i];

            if (coord[i] < aabb.min[i] || coord[i] > aabb.max[i])
                return -1.0;
        }
    }
    return length(coord - ray.origin);
}

float rayTest(const AABB aabb, const Ray ray) {
    vec3 boxmin = aabb.min;
    vec3 boxmax = aabb.max;
    vec3 raypos = ray.origin;
    vec3 raydir = ray.dir;

    float t1 = (boxmin.x - raypos.x) / raydir.x;
    float t2 = (boxmax.x - raypos.x) / raydir.x;
    float t3 = (boxmin.y - raypos.y) / raydir.y;
    float t4 = (boxmax.y - raypos.y) / raydir.y;
    float t5 = (boxmin.z - raypos.z) / raydir.z;
    float t6 = (boxmax.z - raypos.z) / raydir.z;

    float tmin = max(max(min(t1, t2), min(t3, t4)), min(t5, t6));
    float tmax = min(min(max(t1, t2), max(t3, t4)), max(t5, t6));

    if (tmax < 0.0) // box on ray but behind ray origin
    {
        return -1.0;
    }

    if (tmin > tmax) // ray doesn't intersect box
    {
        return -1.0;
    }

    return tmin;
}

AABB normalizedAABB(EncodedAABB e) {
    float x = float(e.x) / 65535.0;
    float y = float(e.y) / 65535.0;
    float z = float(e.z) / 65535.0;
    float ext = 0.5 * pow(0.5, e.depth);
    return AABB(vec3(x-ext, y-ext, z-ext), vec3(x+ext, y+ext, z+ext));
}

struct Sphere {
    vec3 center;
    float radius;
};

float rayTest(const Sphere sphere, const Ray ray) {
    vec3 oc = ray.origin - sphere.center;
    float b = 2.0 * dot(oc, ray.dir);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = b*b - 4*c;
    if (discriminant < 0.0) return -1.0;
    return (-b - sqrt(discriminant)) * 0.5;
}

Sphere normalizedSphere(EncodedAABB e) {
    float x = float(e.x) / 65535.0;
    float y = float(e.y) / 65535.0;
    float z = float(e.z) / 65535.0;
    float radius = 0.5 * pow(0.5, e.depth);
    return Sphere(vec3(x, y, z), radius);
}

float rayResultNearDepth = 1.0;
vec4 rayResultNearColor = vec4(0);
vec3 rayResultNormal = vec3(0);

void runTest(const Ray ray) {
    uint32_t index = 0;
    uint32_t count = data.volumes.length();
    while (index < count) {
        const EncodedAABB e = data.volumes[index];
        const AABB aabb = normalizedAABB(e);
        const float t = rayTest(aabb, ray);
        if (t >= 0.0) {
            if (e.flags != 0) { // leaf-node (has payload)
                float depth = t / info.depth;
                if (depth < rayResultNearDepth) {
                    // update position, data (payload)

                    const uint32_t p = e.payload;
                    rayResultNearColor.r = float(p & 0xff) / 255.0;
                    rayResultNearColor.g = float((p >> 8) & 0xff) / 255.0;
                    rayResultNearColor.b = float((p >> 16) & 0xff) / 255.0;
                    rayResultNearColor.a = float((p >> 24) & 0xff) / 255.0;
                    rayResultNearDepth = depth;

                    vec3 hitPoint = ray.origin + ray.dir * t;
                    vec3 center = (aabb.max + aabb.min) * 0.5;
                    vec3 n = hitPoint - center;
                    rayResultNormal = normalize(n);
                }
            }
            index += 1;
        } else {
            if (e.flags == 0)
                index += e.payload;
            else
                index += 1;
        }
    }
}

vec3 boxNormal(vec3 n) {
    vec3 absn = abs(n);
    if (absn.x > absn.y && absn.x > absn.z) {
        n.yz = vec2(0.0);
    } else if (absn.y > absn.x && absn.y > absn.z) {
        n.xz = vec2(0.0);
    } else {
        n.xy = vec2(0.0);
    }
    return normalize(n);
}

void main() {
    const Ray ray = getRay();
    runTest(ray);
    if (rayResultNearDepth < 1.0) {
        vec3 normal = boxNormal(rayResultNormal);
        normal = normalize((vec4(normal, 0.0) * info.inverseM).xyz);
        float lum = max(dot(normal, normalize(-info.lightDir)), 0.0);
        vec3 color = mix(info.ambientColor.rgb, info.lightColor.rgb * lum, info.lightColor.a);
        vec4 fragColor = rayResultNearColor * vec4(color, 1.0);
        imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), fragColor);
    } else {
        vec4 color = vec4(0, 0, 0, 0);
        imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), color);
    }
}
