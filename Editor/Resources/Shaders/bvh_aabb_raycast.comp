#version 450
#extension GL_EXT_shader_explicit_arithmetic_types         : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int8    : require
#extension GL_EXT_shader_explicit_arithmetic_types_int16   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int32   : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64   : require
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_float64 : require
#extension GL_EXT_debug_printf : enable

layout (push_constant) uniform SceneInfo {
    layout(row_major) mat4 transform; // inverse of model-view-projection
    uint32_t width;  // framebuffer(render-target) dimensions
    uint32_t height;
    float depth;     // frustum depth (farZ - nearZ)
} info;

struct EncodedAABB {
    uint16_t x, y, z;
    uint8_t depth;
    uint8_t flags;
    uint32_t payload;
    uint32_t padding;
};

struct AABB {
    vec3 min;
    vec3 max;
};

layout (std140, binding=0) readonly buffer AABBArray {
    vec3 aabbMin;
    float _padding_12;
    vec3 aabbMax;
    float _padding_28;
    EncodedAABB volumes[];
} data;

layout (binding=1, rgba8) uniform image2D outputImage;

struct Ray {
    vec3 start;
    vec3 dir;
};

Ray getRay() {
    float x = (float(gl_GlobalInvocationID.x) + 0.5) / float(info.width);
    float y = (float(gl_GlobalInvocationID.y) + 0.5) / float(info.height);
    x = x * 2.0 - 1.0;
    y = 1.0 - y * 2.0;

    vec3 scale = data.aabbMax - data.aabbMin;

    vec4 start4 = vec4(x, y, 0.0, 1.0) * info.transform;
    vec4 end4 = vec4(x, y, 1.0, 1.0) * info.transform;
    vec3 start = start4.xyz / start4.w;
    vec3 end = end4.xyz / end4.w;

    start = (start - data.aabbMin) / scale;
    end = (end - data.aabbMin) / scale;

    return Ray(start, normalize(end - start));
}

float rayTest(const AABB aabb, const Ray ray) {
    bool inside = true;
    vec3 maxT = vec3(-1, -1, -1);
    vec3 coord = vec3(0, 0, 0);

    for (int i = 0; i < 3; ++i) {
        if (ray.start[i] < aabb.min[i]) {
            coord[i] = aabb.min[i];
            inside = false;
            if (ray.dir[i] != 0.0) {
                maxT[i] = (aabb.min[i] - ray.start[i]) / ray.dir[i];
            }
        } else if (ray.start[i] > aabb.max[i]) {
            coord[i] = aabb.max[i];
            inside = false;
            if (ray.dir[i] != 0.0) {
                maxT[i] = (aabb.max[i] - ray.start[i]) / ray.dir[i];
            }
        }
    }
    if (inside) return 0.0;

    int plane = 0;
    if (maxT.y > maxT[plane]) plane = 1; // y-axis
    if (maxT.z > maxT[plane]) plane = 2; // z-axis

    if (maxT[plane] < 0.0)
        return -1.0;

    for (int i = 0; i < 3; ++i) {
        if (i != plane) {
            coord[i] = ray.start[i] + maxT[plane] * ray.dir[i];

            if (coord[i] < aabb.min[i] || coord[i] > aabb.max[i])
                return -1.0;
        }
    }
    return length(coord - ray.start);
}

AABB normalizedAABB(EncodedAABB e) {
    float x = float(e.x) / 65535.0;
    float y = float(e.y) / 65535.0;
    float z = float(e.z) / 65535.0;
    float ext = 0.5 * pow(0.5, e.depth);
    return AABB(vec3(x-ext, y-ext, z-ext), vec3(x+ext, y+ext, z+ext));
}

float rayResultNearDistance = 1.0;
vec4 rayResultNearColor = vec4(0, 0, 0, 0);

void runTest(const Ray ray) {
    uint32_t index = 0;
    uint32_t count = data.volumes.length();
    while (index < count) {
        const EncodedAABB e = data.volumes[index];
        const AABB aabb = normalizedAABB(e);
        float t = rayTest(aabb, ray);
        if (t >= 0.0) {
            if (e.flags != 0) { // leaf-node (has payload)
                t = t / info.depth;
                if (t < rayResultNearDistance) {
                    // update position, data (payload)
                    const uint32_t p = e.payload;
                    rayResultNearColor.r = float(p & 0xff) / 255.0;
                    rayResultNearColor.g = float((p >> 8) & 0xff) / 255.0;
                    rayResultNearColor.b = float((p >> 16) & 0xff) / 255.0;
                    rayResultNearColor.a = float((p >> 24) & 0xff) / 255.0;
                    rayResultNearDistance = t;
                }
            }
            index += 1;
        } else {
            if (e.flags == 0)
                index += e.payload;
            else
                index += 1;
        }
    }
}

void main() {
    const Ray ray = getRay();
    runTest(ray);
    if (rayResultNearDistance < 1.0) {
        vec4 color = rayResultNearColor;
        imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), color);
    } else {
        vec4 color = vec4(0, 0, 0, 0);
        imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), color);
    }
}
